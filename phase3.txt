This project was built using Maven. To build, run Maven's compile target. This will install project dependencies, such as
Antlr, and generate java code based on the grammar file. To run the project, add the folder src/target/classes to your classpath,
as well as the Maven dependencies installed in the previous step. Then, run the Main class, passing in the name of the tiger file
you want to parse as the first argument, and either "naive", "cfg", or "ebb" as the second argument. Function calls are not implemented,
floating point numbers are not supported (including readf and printf), and register spilling is not implemented. Much code was written
for the CFG and EBB implementations, but we ran out of time to complete them.

This naive implementation generated new IR based off of the IR generated in phase 2. The IR was largely the same, but added instructions
to load and store each variable reference. This was relatively straightforward because most instructions mapped one-to-one with MIPS
instructions. However, call, callr, array load, and array store required a bit of extra work. For the two function call instructions,
the correct number is loaded into the v0 register. Then, any arguments are added to a0. Lastly, the syscall instruction is issued. For
the read functions, the result is moved from v0 to the appropriate return register. For the array operations, the address was loaded
into a register, the offset was calculated by multiplying the index by 4 to get to the correct word, and that value was added to the
address of the array. Then the value was either loaded or stored.

The CFG was generated by first finding leader statements, and then partitioning the IR into basic blocks between the leaders. Necessary
variables are loaded at the beginning of each BB, and stored at the end.

The EBB implementation used the algorithm in the project assignment page to generate the extended basic blocks. At the beginning of each
EBB, necessary loads were performed. They were stored again at the end of the EBB.

In order to keep the actual instruction selection separate from the three implementations, we designed an interface between the implementations
and the MIPSGenerator. This was as simple as deciding on a standard format that each implementation returned to be passed to the MIPSGenerator.
We focused on keeping the most efficient implementation of the operations in the MIPSGenerator and leaving any inefficiency to the three
implementations. For example, the actual instructions generated during an array store should be handled by the MIPSGenerator, but the specific
registers to use and when values are loaded / stored should be handled by the implementation.

We used the testcase07 under ir from phase2-testcases to generate spim stats.
naive: #instructions : 385 #reads : 72  #writes 58  #branches 48  #other 207
